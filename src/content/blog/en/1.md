---
title: 'TypeScript Implementation of JSON Schema and Technical Considerations'
description: 'This article explains the background and process of developing a TypeScript implementation of JSON Schema, along with test automation strategies using JSON-Schema-test-suite. It also covers the challenges and solutions related to implementing RFC standard-based Format keywords.'
createdAt: 2025-01-09
publishedAt: 2025-01-09
updatedAt: 2025-02-07
---

In recent years, as data validation has become increasingly important, various validation libraries have emerged centered around [JSON Schema](#json-schema). Notable examples include [Zod](#zod), [Ajv](#ajv), and [class-validator](#class-validator). I too became fascinated by the possibilities of JSON Schema and began exploring this field.

Initially, I planned to use Ajv, but during development, I discovered several limitations that ultimately led me to develop my own library. In this article, I'll share the technical challenges I faced, how I resolved them, and the insights gained along the way.

## 1. Limitations of Existing Libraries and Motivation

While [Ajv](#ajv) is the most widely used library in the JSON Schema ecosystem, it had the following type inference limitations in TypeScript environments:

```ts
import Ajv from 'ajv';

const ajv = new Ajv();

const validate = ajv.compile({
  type: 'object',
  // ‚ùå Even when starting to input here, it doesn't infer valid keywords for 'object' type
});

const data = {
  foo: 1,
  bar: 'hello',
}

// ‚ùå Since validate() returns boolean, TypeScript cannot guarantee type safety
if (validate(data)) {
  data.foo // ‚ùå Cannot access 'foo' property
}
```

While this issue can be partially resolved using [Ajv Utility Types](#ajv-typescript), it creates a new problem of **having to maintain schema and type definitions separately**. Ideally, I believed the schema definition itself should provide type information.

## 2. Development Approach Decision

To address these issues, I considered two approaches:

1. Extending existing libraries to improve type inference
2. Developing a new implementation optimized for type inference from scratch

After careful consideration, I chose the second approach. Building a completely new implementation would allow me to design the type system from the ground up and provide a better developer experience.

## 3. Major Technical Challenges and Solutions

The two biggest challenges I encountered while developing the new library were test automation and Format keyword implementation.

### 3-1. Test Automation

The JSON Schema team provides test cases in JSON Schema format through the [JSON-Schema-test-suite](#JSON-Schema-Test-Suite) repository.

#### 3-1-1. Initial Approach

Initially, I attempted the following method:

1. Synchronize repository
2. Collect version-specific test files by reading directories
3. Generate type definitions using [TS Compiler API](#ts-compiler-api)
4. Write test functions using generated types

#### 3-1-2. Implementation Process

First, I wrote a `cli` for repository synchronization:

```ts
#!/usr/bin/env node

// Repository sync
await gitFetch({
  org: "json-schema-org",
  repo: "JSON-Schema-Test-Suite",
});

// Generate type definitions
await writeTsFile(createInterface("Vocabulary", vocabulary));
await writeTsFile(createInterface("Alias", alias));
await writeTsFile(createType("Version", Object.keys(vocabulary)));
```

Then I created a manager class for test execution:

```ts
export class TestCaseManager<T extends keyof Vocabulary = keyof Vocabulary> {
  constructor(public readonly version: T) {}

  load = memoize(
    async <K extends Vocabulary[T]>(
    keyword: K,
    options?: { skip?: string[] },
    ) => { ... },
  );
}

// Instance for testing latest version
export const latestTestCase = new TestCaseManager("latest");
```

The actual test code using this looks like:

```ts
import { expect, test } from "vitest";
import { Schema } from "../../schema.js";
import {
  TestCaseManager,
  latestTestCase,
} from "../../utils/test-case-manager.js";

test.concurrent.for(await latestTestCase.load("additionalProperties"))(
  TestCaseManager.format,
  (testCase) => {
    const schema = new Schema(testCase.schema);
    expect(schema.validate(testCase.data)).toBe(testCase.expected);
  },
);
```

#### 3-1-3. Identified Improvements

However, this approach had significant issues:

1. **Performance Issues**: Dynamically reading files resulted in slow execution times
2. **Complexity**: Test setup and execution processes were unnecessarily complex

To address these issues, I developed a **test file auto-generation CLI tool** using the TS Compiler API.

However, I later discovered that the JSON Schema team already provided [Bowtie](#bowtie), a powerful CLI testing tool.

### 3-2. Format Keyword Implementation

#### 3-2-1. Initial Implementation Approach

The [Format keyword](#format-keyword) in JSON Schema provides validation functionality based on various **RFC standards**. For example, it can validate specific string formats like `date-time` or `uri`.

I determined that this functionality was too broad to be included in the same library. Therefore, I decided to separate it into a **separate library** and provide an interface similar to the familiar native [JSON API](#json-api) and [Date API](#date-api).

```ts
import { FullTime } from "@imhonglu/format";

// Parse time string according to RFC standard
const time = FullTime.parse("15:59:60.123-08:00", {
  year: 1998,
  month: 12,
  day: 31,
});
// Result:
// {
//   hour: 15,        // Hour
//   minute: 59,      // Minute
//   second: 60,      // Second (considering leap second)
//   secfrac: ".123", // Fraction of second
//   offset: {        // Timezone offset
//     sign: "-",     // Sign
//     hour: 8,       // Hour
//     minute: 0      // Minute
//   }
// }

// Convert to standard format string
console.log(FullTime.stringify(time));
// '15:59:60.123-08:00'

// Support JSON serialization
console.log(JSON.stringify(time));
// '"15:59:60.123-08:00"'

// Automatic serialization within objects
console.log(
  JSON.stringify({
    name: "John",
    createdAt: time,  // FullTime instance automatically converts to string
  })
)
// '{"name":"John","createdAt":"15:59:60.123-08:00"}'
```

#### 3-2-2. Serializable Decorator

First, I implemented a [Serializable Decorator](#serializable-decorator) to easily define frequently used [Formatters](#formatter).

```ts
import {
  type Fn,
  type SafeResult,
  createSafeExecutor,
} from "@imhonglu/toolkit";

export function Serializable<
  T extends Fn.Newable & {
    parse: Fn.Callable<{ return: InstanceType<T> }>;
    safeParse: Fn.Callable<{ return: SafeResult<InstanceType<T>> }>;
    stringify: Fn.Callable<{ args: [InstanceType<T>]; return: string }>;
  },
>(targetClass: T) { ... }
```

I chose to create this as a `Decorator` because it could be used like an `Abstract Implement Class` ([related issue](#abstract-implement-class-related-issue)) through `Generics` and could automatically implement specific methods.

For example:

```ts
@Serializable
// ^^^^^^^^^^
// Throws an error if `parse`, `stringify`, `safeParse` methods
// are not implemented
class MyClass { ... }
```

```ts
@Serializable
class MyClass {
  ...
  // Automatically implements `toString()`, `toJSON()`, `safeParse()` methods
}
```

#### 3-2-3. ABNF Grammar and Regular Expressions

Converting [ABNF](#abnf-wiki) grammar from RFC documents to regular expressions presented challenges in code reusability and debugging. This was particularly evident in implementing `uri` from [RFC 3986](#rfc-3986).

For example, regular expressions like this are difficult to debug when characters are missing or need updating:

```ts
const userinfo = /[a-zA-Z0-9\-._~!$&'()*+,;=:]+/;
```

To solve this, I developed the [@imhonglu/pattern-builder](#imhonglupattern-builder) library using the [Builder Pattern](#builder-pattern). This library enables writing ABNF grammar in a clearer and more maintainable way.

First, define basic patterns:

```ts
import { characterSet, concat, hexDigit } from "@imhonglu/pattern-builder";

export const unreserved = characterSet(alpha, digit, /[\-._~]/);
export const pctEncoded = concat("%", hexDigit.clone().exact(2));
export const subDelims = characterSet(/[!$&'()*+,;=]/);
```

These basic patterns can be combined to create more complex patterns:

```ts
export const pchar = oneOf(
  pctEncoded,
  characterSet(unreserved, subDelims, /[:@]/),
);
```

Finally, the URI path pattern is constructed as:

```ts
const slash = characterSet("/").optional();

const path = concat(
  concat(slash, pchar.clone().nonCapturingGroup().oneOrMore())
    .nonCapturingGroup()
    .zeroOrMore(),
  // Optional trailing slash
  slash,
)
  .anchor()
  .toRegExp();
```

This stepwise pattern construction approach offers several advantages:

- Clearly expresses the intent and role of ABNF rules
- Makes individual patterns easy to modify
- Enables testing and debugging per pattern
- Allows easy reuse of defined patterns in other rules

## JSON Schema Implementation Introduction

Through resolving these challenges, I developed a library with the following features:

The demo below showcases the key features of my library:

![../../../../public/blog/post-1/demo.gif](../../../../public/blog/post-1/demo.gif)

### üõ† Library Features

- Complies with JSON Schema 2020-12 Draft specification
- Statically infers appropriate keywords when defining schemas
- Statically infers types from defined schemas
- Supports recursive type inference for nested `Schema Instances`
- Enables type inference based on `required` keywords
- Provides `parse` and `stringify` methods for easy schema conversion and utilization
- Verified based on [JSON-Schema-test-suite](#json-schema-test-suite)

Unexpectedly, I spent more time developing automatic test case generation based on JSON-Schema-test-suite than solving type problems. Additionally, significant effort went into analyzing RFC specifications for `format` keyword support. While this process took longer than anticipated, it ultimately improved the project's quality.

### üöÄ Future Plans

While basic functionality is implemented, there's still room for improvement. Future focus areas include:

1. **Custom Features**
   - Schema validation message customization
   - Custom error handling
   - Validation rule extension support

2. **Developer Experience Improvements**
   - More detailed error messages and debugging information
   - Documentation improvements

3. **Performance Optimization**
   - Schema compilation process optimization
   - Memory usage improvements

### ü§ù Contributing

This project is still evolving and welcomes community feedback and contributions. If interested, please visit the [repository](https://github.com/imhonglu/new-wheels/tree/main/libs/json-schema).

Your opinions and suggestions will drive this library's continued improvement. Thank you! üöÄ

[Previous content...]

## References

#### [Zod](https://zod.dev/)
A powerful library that ensures type safety in TypeScript and can validate various data structures. It particularly excels at schema-based data validation.

#### [class-validator](https://github.com/typestack/class-validator)
A decorator-based library commonly used with `NestJS` that validates object properties. It provides various validation decorators.

#### [Ajv](https://github.com/ajv-validator/ajv)
A high-performance library for validating data using JSON Schema, widely used in Node.js environments. It supports the latest JSON Schema standards.

#### [JSON Type Definition](https://json-schema.org/draft/2020-12/json-schema-type-definitions)
A standard specification for defining and validating JSON data types, offering a more concise syntax compared to JSON Schema.

#### [JSON Schema](https://json-schema.org/)
A draft specification for defining and validating JSON data structures, supporting various data formats and ensuring data validity.

#### [Ajv TypeScript](https://ajv.js.org/guide/typescript.html#utility-types-for-schemas)
Documentation for Ajv's TypeScript utility types that enhance interoperability between JSON Schema and TypeScript types.

#### [TS Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
A powerful API for programmatically analyzing and transforming TypeScript code, allowing access to TypeScript compiler's internal functionality.

#### [Format Keyword](https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-7)
A keyword in JSON Schema for validating strings of specific formats, enabling validation of various data format types.

#### [JSON-Schema-Test-Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite)
The official collection of test cases for verifying JSON Schema implementations.

#### [JSON-Schema-Test-Suite/tree/main/tests](https://github.com/json-schema-org/JSON-Schema-Test-Suite/tree/main/tests)
Directory containing test schemas for the JSON Schema Test Suite, including various test cases.

#### [sh](https://github.com/imhonglu/new-wheels/blob/main/tools/build-tools/src/utils/sh.ts)
A utility function for executing shell commands, making it easy to run system commands in Node.js environments.

#### [gitFetch](https://github.com/imhonglu/new-wheels/blob/main/tools/build-tools/src/utils/git-fetch.ts)
A utility function for synchronizing Git repositories, enabling fetching of the latest state from remote repositories.

#### [Bowtie](https://docs.bowtie.report/en/stable/)
A CLI tool for automating tests of JSON Schema implementations, facilitating easy execution of various test cases.

#### [JSON API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON)
The standard API for handling JSON data in JavaScript, enabling conversion between JSON strings and objects.

#### [Date API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
The standard API for handling dates and times in JavaScript, allowing creation and manipulation of date objects.

#### Formatter
An internal implementation term referring to components that perform string format validation based on RFC standards.

#### [Serializable Decorator](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/utils/serializable/serializable.ts)
A `Class Decorator` for implementing [Formatter](#formatter).

#### [Abstract Implement Class Related Issue](https://github.com/microsoft/TypeScript/issues/22815)
A TypeScript issue discussing abstract implementation classes, including details about abstract class implementation specifics.

#### [ABNF WIKI](https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form)
Wiki page about ABNF used in RFC documents, explaining how to define formal language grammar.

#### [RFC 5234](https://datatracker.ietf.org/doc/html/rfc5234)
The RFC document defining ABNF, providing standards for defining formal language grammar.

#### [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986)
The RFC document defining the general syntax of URIs, explaining URI structure and format.

#### [@imhonglu/pattern-builder](https://github.com/imhonglu/new-wheels/blob/main/libs/pattern-builder/src/index.ts)
A library facilitating easy regular expression creation, enabling simple construction of complex patterns.

#### [@imhonglu/format](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/index.ts)
A library for string format validation based on RFC documents, supporting validation of various string formats.

#### [Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern)
A design pattern for object creation that simplifies complex object construction processes and provides flexibility.
