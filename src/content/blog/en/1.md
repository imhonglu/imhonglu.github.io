---
title: 'Implementing JSON Schema in TypeScript: From Type Inference to RFC Standards'
description: 'Sharing technical challenges and solutions encountered while implementing JSON Schema in TypeScript, focusing on type inference, test automation, and RFC standard implementation. Particularly addressing approaches to ensure type safety and improve developer experience.'
createdAt: 2025-01-09
publishedAt: 2025-01-09
updatedAt: 2025-02-11
---

In the JavaScript/TypeScript ecosystem, various data validation libraries have emerged and evolved with different approaches.

[Zod](#zod) provides a declarative API, [Ajv](#ajv) faithfully follows the [JSON Schema](#json-schema) draft, and [class-validator](#class-validator) supports decorator-based validation.

Within this landscape, I was drawn to the flexibility and extensibility of JSON Schema and decided to explore it deeply.

Initially, I planned to use Ajv, but after encountering certain limitations during development, I decided to create my own library.

In this article, I'll share the technical challenges faced, solutions implemented, and insights gained during this process.

## Limitations of Existing Libraries and Motivation

While Ajv is the most widely used library in the JSON Schema ecosystem, it had type inference limitations in TypeScript environments:

```ts
import Ajv from 'ajv';

const ajv = new Ajv();

const validate = ajv.compile({
  type: 'object',
  // ❌ Even when starting to type here, valid keywords for 'object' type are not inferred
});

const data = {
  foo: 1,
  bar: 'hello',
}

// ❌ Since validate() returns boolean, TypeScript cannot guarantee type safety
if (validate(data)) {
  data.foo // ❌ Cannot access property 'foo'
}
```

While this issue can be resolved using [Ajv Utility Types](#ajv-typescript), it creates a new problem of **having to maintain schema and type definitions separately**. Ideally, I believed the schema definition itself should provide type information.

## Development Approach Decision

To address these issues, I considered two approaches:

1. Extending existing libraries to improve type inference
2. Developing a new implementation optimized for type inference from scratch

After careful consideration, I chose the second approach. Building a completely new implementation would allow designing the type system from the ground up and provide a better developer experience.

## Key Technical Challenges and Solutions

During the development of the new library, I prioritized three core challenges:

1. **Test Automation** – How to efficiently validate various JSON Schema test cases
2. **Format Keyword Implementation** – How to support format validation while maintaining RFC compliance and maintainability
3. **Type Inference** – How to implement a type system reflecting JSON Schema's structural characteristics

Let me share what problems we encountered and how we solved them.

## Test Automation

The JSON Schema team provides various test cases through the [JSON-Schema-test-suite](#json-schema-test-suite) repository.

While these test cases were invaluable for validating implementation correctness, we faced several challenges in efficiently managing and executing them.

The key goal was to **automate tests and ensure consistent execution**.

### Initial Approach

Initially, we attempted test automation with the following approach:

1. Sync repository to fetch latest test cases
2. Analyze directory structure and collect version-specific test files
3. Generate type definitions for each test case using TS Compiler API
4. Write and execute automated test functions using generated types

### Implementation Process

First, we wrote CLI scripts and necessary utilities to **automate repository synchronization**.
This enabled quick and reliable fetching of the latest test cases to the local environment.

```ts
#!/usr/bin/env node

// Repository sync
await gitFetch({
  org: "json-schema-org",
  repo: "JSON-Schema-Test-Suite",
});

// Type definition generation
await writeTsFile(createInterface("Vocabulary", vocabulary));
await writeTsFile(createInterface("Alias", alias));
await writeTsFile(createType("Version", Object.keys(vocabulary)));
```

Next, we designed a `TestCaseManager` class to easily manage test execution:

```ts
export class TestCaseManager<T extends keyof Vocabulary = keyof Vocabulary> {
  constructor(public readonly version: T) {}

  load = memoize(
    async <K extends Vocabulary[T]>(
    keyword: K,
    options?: { skip?: string[] },
    ) => { ... },
  );
}

// Instance for latest version testing
export const latestTestCase = new TestCaseManager("latest");
```

After these preparations, we could automate JSON Schema validation in actual test code using `TestCaseManager`:

```ts
import { expect, test } from "vitest";
import { Schema } from "../../schema.js";
import {
  TestCaseManager,
  latestTestCase,
} from "../../utils/test-case-manager.js";

test.concurrent.for(await latestTestCase.load("additionalProperties"))(
  TestCaseManager.format,
  (testCase) => {
    const schema = new Schema(testCase.schema);
    expect(schema.validate(testCase.data)).toBe(testCase.expected);
  },
);
```

### Trial and Error and Improvements

While this approach initially seemed effective, we discovered several important issues:

1. **Performance Issues** – Dynamically reading all test files inevitably led to slower execution times
2. **Maintenance Complexity** – Paradoxically, maintaining the automation tools became more time-consuming than expected

To address these issues, we developed a **test file auto-generation CLI tool** using the TS Compiler API.

After completion, we discovered [Bowtie](#bowtie), the JSON Schema team's official CLI testing tool.

It effectively handled the problems we were trying to solve, but our tool development was already complete.

We decided to be more thorough in researching existing tools for future projects.

## Format Keyword Implementation

JSON Schema's [Format keyword](#format-keyword) provides validation functionality based on various **RFC standards**. For example, it can validate specific string formats like `date-time` or `uri`.

I determined that this functionality was too broad to be simply included in the same library.

Therefore, I decided to separate this functionality into a **separate library** and provide an interface similar to the familiar native [JSON API](#json-api) and [Date API](#date-api).

```ts
import { FullTime } from "@imhonglu/format";

// Parse time string according to RFC standard
const time = FullTime.parse("15:59:60.123-08:00", {
  year: 1998,
  month: 12,
  day: 31,
});
// Result:
// {
//   hour: 15,        // Hour
//   minute: 59,      // Minute
//   second: 60,      // Second (considering leap second)
//   secfrac: ".123", // Fraction of second
//   offset: {        // Timezone offset
//     sign: "-",     // Sign
//     hour: 8,       // Hour
//     minute: 0      // Minute
//   }
// }

// Convert to standard format string
console.log(FullTime.stringify(time));
// '15:59:60.123-08:00'

// Support JSON serialization
console.log(JSON.stringify(time));
// '"15:59:60.123-08:00"'

// Automatic serialization within objects
console.log(
  JSON.stringify({
    name: "John",
    createdAt: time,  // FullTime instance automatically converts to string
  })
)
// '{"name":"John","createdAt":"15:59:60.123-08:00"}'
```

### Serializable Decorator

First, I implemented the [Serializable Decorator](#serializable-decorator) to easily define repeatedly used `Formatters`.

> `Formatter` refers to the internal implementation that validates string formats (email, date, etc.) based on RFC standards.

```ts
import {
  type Fn,
  type SafeResult,
  createSafeExecutor,
} from "@imhonglu/toolkit";

export function Serializable<
  T extends Fn.Newable & {
    parse: Fn.Callable<{ return: InstanceType<T> }>;
    safeParse: Fn.Callable<{ return: SafeResult<InstanceType<T>> }>;
    stringify: Fn.Callable<{ args: [InstanceType<T>]; return: string }>;
  },
>(targetClass: T) { ... }
```

There were two reasons for using the `Decorator`:

First, using `Generic` allows it to act like an `Abstract Implement Class`. As discussed in TypeScript's [related issue](#abstract-implement-class-related-issue), constraints can be enforced through `Decorator`.

```ts
@Serializable
// ^^^^^^^^^^
// ❌ Compilation error if `parse`, `stringify`, `safeParse` are not implemented
// due to Generic type constraints
class MyClass { }
```

Second, while satisfying the first condition, it automatically implements certain methods (`toString`, `toJSON`, `safeParse`, etc.).

```ts
@Serializable
class MyClass {
  public static parse() { ... }
  public static stringify() { ... }
  public static safeParse: SafeExecutor<typeof MyClass.parse>;
}

MyClass.safeParse(...); // ✅ Call automatically implemented `safeParse` method
```

Using `Decorator` this way ensures type safety while reducing repetitive boilerplate code.

### ABNF Grammar and Regular Expressions

When converting [ABNF](#abnf-wiki) grammar from RFC documents to regular expressions, we encountered issues with code **reusability and debugging**. This limitation was particularly evident in implementing `uri` from [RFC 3986](#rfc-3986).

For example, with regular expressions like this, it was **very difficult to identify where problems occurred** if certain characters were missing or updated:

```ts
const userinfo = /[a-zA-Z0-9\-._~!$&'()*+,;=:]+/;
```

#### Solution

To solve this problem, we developed the [@imhonglu/pattern-builder](#imhonglupattern-builder) library applying the [Builder Pattern](#builder-pattern). This allows **converting ABNF grammar into more intuitive and maintainable code**.

First, we define the most basic patterns:

```ts
import { characterSet, concat, hexDigit } from "@imhonglu/pattern-builder";

export const unreserved = characterSet(alpha, digit, /[\-._~]/);
export const pctEncoded = concat("%", hexDigit.clone().exact(2));
export const subDelims = characterSet(/[!$&'()*+,;=]/);
```

These defined patterns can be combined to create more complex rules:

```ts
export const pchar = oneOf(
  pctEncoded,
  characterSet(unreserved, subDelims, /[:@]/),
);
```

And finally complete the **URI path pattern**:

```ts
const slash = characterSet("/").optional();

const path = concat(
  concat(slash, pchar.clone().nonCapturingGroup().oneOrMore())
    .nonCapturingGroup()
    .zeroOrMore(),
  // Optional trailing slash
  slash,
)
  .anchor()
  .toRegExp();
```

#### Improvements

Thanks to the step-by-step pattern definition approach:

- We can more clearly express the **intent and role** of ABNF rules
- Each pattern can be modified and reused independently
- Specific parts can be tested and debugged separately

This pattern builder approach significantly improved **code readability and maintainability**, becoming a crucial foundation for implementing core functionality in the [@imhonglu/format](#imhongluformat) library.

## Type Inference

Through the Format keyword implementation and test automation discussed earlier, we laid the foundation for the library. However, the most important aspect in a TypeScript environment is **type safety**. The final challenge was to effectively implement type inference for JSON Schema.

Rather than simply inferring based on the `type` keyword, we needed an **extensible type system that reflects the structural characteristics of the schema**.

### Type System Structuring

First, we defined the `type` keyword as a **Discriminated Union** to narrow down possible types in advance.
This allowed us to leverage TypeScript's type analysis features for automatic type inference (Control Flow Analysis).

However, JSON Schema is not defined by simple `type` properties alone.
There are various keywords for validation, which needed to be managed systematically.

Therefore, we adopted an approach of **separating major keywords used in JSON Schema into reusable interfaces**,
clearly defining necessary properties for each type.

We organized this into six categories based on documentation:

1. **`BasicMetaData`** - Metadata properties like `title`, `description`, `default`
2. **`StructuralValidation`** - Properties for structural validation of numbers, strings, arrays, etc.
3. **`StringEncodedData`** - String data related properties like `contentEncoding`, `contentMediaType`
4. **`Format`** - Format validation like `date-time`, `email`, `uri`
5. **`ApplyingSubSchema`** - Sub-schema related properties like `$ref`, `allOf`, `oneOf`, `anyOf`
6. **`UnevaluatedLocations`** - Additional property definitions like `unevaluatedProperties`, `unevaluatedItems`

Let's look at `StructuralValidation` as an example:

```ts
export namespace StructuralValidation {
  /**
   * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.2 | Numeric}
   */
  export interface Numeric {
    multipleOf?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    minimum?: number;
    exclusiveMinimum?: number;
  }

  /**
   * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.3 | String}
   */
  export interface String {
    maxLength?: number;
    minLength?: number;
    pattern?: string;
  }
  // ... omitted
```

By separating each property into independent interfaces, we can **compose desired schema types by combining only necessary properties**.

### JSON Schema Type Definition

Based on the structure separated above, we can define the top-level JSON Schema type:

```ts
/**
 * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-01#section-4.3.1 | ObjectSchema}
 */
export interface ObjectSchema
  extends Core<JsonSchema>,
    BasicMetaData,
    StructuralValidation.All,
    StringEncodedData<JsonSchema>,
    Format,
    ApplyingSubSchema.All<JsonSchema>,
    UnevaluatedLocations.All<JsonSchema> {}

/**
 * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-01#section-4.3.2 | BooleanSchema}
 */
export type BooleanSchema = boolean;

export type JsonSchema = ObjectSchema | BooleanSchema;
```

> BooleanSchema is different from the `type: "boolean"` property. `true` allows all values and `false` rejects all values, acting as a simple schema that only validates the existence of data.

Now we can **integrate the core type structure of JSON Schema**.

This can be extended to define more specific types:

```ts
export namespace SchemaDefinition {
  // ... omitted

  export interface NumericType
    extends Core<Type>,
      BasicMetaData,
      Pick<StructuralValidation.Any, "type">,
      StructuralValidation.Numeric {
    type: "number" | "integer";
  }

  export type Type =
    | BooleanSchema
    | ConstType
    | EnumType
    | NullType
    | BooleanType
    | ObjectType
    | ArrayType
    | StringType
    | NumericType
    | Schema;
}
```

### Applying Type Inference

By applying the types defined above as `Generic` to the `Schema` class, we can now statically declare JSON Schema structures:

```ts
export class Schema<T extends SchemaDefinition.Type = SchemaDefinition.Type> {
  constructor(public schema: T) {}
  // ... omitted
}
```

```ts
// Schema instance creation example
const schema = new Schema({
  type: "object",
  // ✅ TypeScript automatically infers allowed keywords for 'object' type
  // e.g., properties, required, additionalProperties, etc.
  properties: {
    name: { 
      type: "string",
      // ✅ TypeScript automatically infers allowed keywords for 'string' type
      // e.g., maxLength, minLength, pattern, etc.
      maxLength: 10,
    },
  },
});
```

This allows us to actively utilize TypeScript's type checking when defining schemas to **reduce developer mistakes and perform safe data validation**.

## JSON Schema Implementation Introduction

Let's look at the actual operation of the library developed while solving the various challenges explained so far.

The demo below shows how type inference works:

![../../../../public/blog/post-1/demo.gif](../../../../public/blog/post-1/demo.gif)

### 🛠 Library Features

- Complies with JSON Schema 2020-12 Draft specification
- Statically infers appropriate keywords when defining schemas
- Statically infers types of determined schemas
- Supports recursive type inference for nested `Schema Instance`
- Enables type inference based on `required` keyword
- Provides `parse`, `stringify` methods for easy schema conversion and utilization
- Validated based on [JSON-Schema-test-suite](#json-schema-test-suite)

Initially, I just wanted to solve the type inference problem, but the development process took unexpected directions.

Test automation using JSON-Schema-test-suite and implementing the `format` keyword based on RFC specifications required more time and effort than expected.

Although the development period was longer than initially planned, these challenges actually became an opportunity to raise the project's completeness to the next level.

### 🚀 Future Plans

While basic functionality is implemented, there's still room for improvement. We plan to focus on developing the following areas:

1. **Custom Features**
   - Customizing schema validation messages
   - Custom error handling
   - Supporting validation rule extensions

2. **Developer Experience Improvement**
   - Providing more detailed error messages and debugging information
   - Documentation improvement

3. **Performance Optimization**
   - Optimizing schema compilation process
   - Improving memory usage

### 🤝 Contributing

This project is still evolving and welcomes community feedback and contributions. If you're interested, please visit the [repository](https://github.com/imhonglu/new-wheels/tree/main/libs/json-schema).

Your opinions and suggestions will be the driving force for further improving this library. Thank you!

## References

#### [Zod](https://zod.dev/)
A powerful library that ensures type safety in TypeScript and can validate various data structures. Particularly useful for easy schema-based data validation.

#### [class-validator](https://github.com/typestack/class-validator)
Used with `NestJS`, this library enables object validation using decorators. Provides various validation decorators.

#### [Ajv](https://github.com/ajv-validator/ajv)
A high-performance library widely used in Node.js environments for validating data using JSON Schema. Supports the latest JSON Schema standards.

#### [JSON Type Definition](https://json-schema.org/draft/2020-12/json-schema-type-definitions)
A standard specification for defining and validating JSON data types, similar to JSON Schema but with more concise syntax.

#### [JSON Schema](https://json-schema.org/)
A draft specification for defining and validating JSON data structures, supporting various data formats and ensuring data validity.

#### [Ajv TypeScript](https://ajv.js.org/guide/typescript.html#utility-types-for-schemas)
Documentation on using Ajv's TypeScript utility types to enhance interoperability between JSON Schema and TypeScript types.

#### [TS Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
A powerful API for programmatically analyzing and transforming TypeScript code, utilizing TypeScript compiler's internal features.

#### [Format Keyword](https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-7)
A keyword in JSON Schema for validating specific string formats, enabling validation of various data format types.

#### [JSON-Schema-Test-Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite)
Official collection of test cases for validating JSON Schema implementations.

#### [Bowtie](https://docs.bowtie.report/en/stable/)
A CLI tool for automating JSON Schema implementation tests, enabling easy execution of various test cases.

#### [JSON API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON)
Standard API for handling JSON data in JavaScript, enabling conversion between JSON strings and objects.

#### [Date API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
Standard API for handling dates and times in JavaScript, enabling creation and manipulation of date objects.

#### [Serializable Decorator](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/utils/serializable/serializable.ts)
A `Class Decorator` for implementing `Formatter`.

#### [Abstract Implement Class Related Issue](https://github.com/microsoft/TypeScript/issues/22815)
TypeScript issue related to abstract implementation classes, including discussions about implementation details of abstract classes.

#### [ABNF WIKI](https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form)
Wiki about ABNF used in RFC documents, explaining how to define formal language grammar.

#### [RFC 5234](https://datatracker.ietf.org/doc/html/rfc5234)
RFC document defining ABNF, providing standards for defining formal language grammar.

#### [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986)
RFC document defining general URI syntax, explaining URI structure and format.

#### [@imhonglu/pattern-builder](https://github.com/imhonglu/new-wheels/blob/main/libs/pattern-builder/src/index.ts)
Library helping to easily write regular expressions, enabling simple construction of complex patterns.

#### [@imhonglu/format](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/index.ts)
Library for string format validation based on RFC documents, enabling validation of various string formats.

#### [Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern)
A design pattern that simplifies complex object creation processes and provides flexibility.
