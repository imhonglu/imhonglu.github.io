---
title: 'Implementing JSON Schema in TypeScript: From Type Inference to RFC Standards'
description: 'This article shares the technical challenges and solutions encountered while implementing JSON Schema in TypeScript, including type inference, test automation, and RFC standard implementation. It particularly focuses on various approaches to ensure type safety and improve developer experience.'
createdAt: 2025-01-09
publishedAt: 2025-01-09
updatedAt: 2025-02-10
---

Recently, various data validation libraries have emerged in the JavaScript/TypeScript ecosystem, each evolving with different approaches. [Zod](#zod) provides a declarative API, [Ajv](#ajv) faithfully follows the JSON Schema draft, and [class-validator](#class-validator) supports decorator-based validation. Within this landscape, I was drawn to the flexibility and extensibility of JSON Schema, which led me to explore it in depth.

Initially, I planned to use Ajv, but after experiencing some limitations during development, I concluded that I needed to create my own library. In this post, I'll share the technical challenges faced, solutions found, and insights gained during this process.

## Limitations of Existing Libraries and Motivation

While Ajv is the most widely used library in the JSON Schema ecosystem, it had the following type inference limitations in TypeScript environments:

```ts
import Ajv from 'ajv';

const ajv = new Ajv();

const validate = ajv.compile({
  type: 'object',
  // ‚ùå Even when starting to input here, it doesn't infer valid keywords for the 'object' type
});

const data = {
  foo: 1,
  bar: 'hello',
}

// ‚ùå Since validate() returns boolean, TypeScript cannot guarantee type safety
if (validate(data)) {
  data.foo // ‚ùå Cannot access 'foo' property
}
```

While this issue can be resolved using [Ajv Utility Types](#ajv-typescript), it creates a new problem of **having to maintain schema and type definitions separately**. Ideally, I believed the schema definition itself should provide type information.

## Development Approach Decision

To address these issues, I considered two approaches:

1. Extending existing libraries to improve type inference
2. Developing a new implementation optimized for type inference from scratch

After careful consideration, I chose the second approach. Building a completely new implementation would allow me to design the type system from the ground up and provide a better developer experience.

## Key Technical Challenges and Solutions

During the development of the new library, there were three core challenges to address:

1. **Test Automation** ‚Äì How to efficiently validate various JSON Schema test cases
2. **Format Keyword Implementation** ‚Äì How to support format validation in a maintainable way while complying with RFC standards
3. **Type Inference** ‚Äì How to effectively implement type inference for JSON Schema

Let me share what problems we encountered and how we solved them.

## Test Automation

The JSON Schema team provides various JSON Schema test cases through the [JSON-Schema-test-suite](#json-schema-test-suite) repository.

While these test cases were invaluable for validating the implementation's accuracy, we faced several challenges in managing and executing them efficiently.

The key challenge was **creating an automated and consistent way to run these tests**.

### Initial Approach

Initially, we attempted test automation in the following way:

1. Synchronize the repository to fetch the latest test cases
2. Analyze directory structure and collect version-specific test files
3. Generate type definitions for each test case using the TS Compiler API
4. Write and execute automated test functions using the generated types

### Implementation Process

First, **we wrote CLI scripts and necessary utilities to automate repository synchronization**. This enabled quick and reliable fetching of the latest test cases to the local environment.

```ts
#!/usr/bin/env node

// Repository synchronization
await gitFetch({
  org: "json-schema-org",
  repo: "JSON-Schema-Test-Suite",
});

// Type definition generation
await writeTsFile(createInterface("Vocabulary", vocabulary));
await writeTsFile(createInterface("Alias", alias));
await writeTsFile(createType("Version", Object.keys(vocabulary)));
```

Next, we designed a `TestCaseManager` class to easily manage test execution:

```ts
export class TestCaseManager<T extends keyof Vocabulary = keyof Vocabulary> {
  constructor(public readonly version: T) {}

  load = memoize(
    async <K extends Vocabulary[T]>(
    keyword: K,
    options?: { skip?: string[] },
    ) => { ... },
  );
}

// Instance for latest version testing
export const latestTestCase = new TestCaseManager("latest");
```

Now we could automate JSON Schema validation in actual test code using `TestCaseManager`:

```ts
import { expect, test } from "vitest";
import { Schema } from "../../schema.js";
import {
  TestCaseManager,
  latestTestCase,
} from "../../utils/test-case-manager.js";

test.concurrent.for(await latestTestCase.load("additionalProperties"))(
  TestCaseManager.format,
  (testCase) => {
    const schema = new Schema(testCase.schema);
    expect(schema.validate(testCase.data)).toBe(testCase.expected);
  },
);
```

### Trial and Error and Improvements

While this approach initially seemed effective, we discovered several significant issues:

1. **Performance Issues** ‚Äì Dynamically reading all test files inevitably led to slower execution speeds
2. **Maintenance Complexity** ‚Äì We created automation tools, but paradoxically ended up spending more time maintaining these tools

While we even created a CLI tool using the TS Compiler API for automatic test file generation to solve these issues, over time I began to question:

> "Why did I build this...?"

Then, I discovered that the JSON Schema team already provided a powerful CLI testing tool called [Bowtie](#bowtie).

> "Ah... it was all there already..."

Finally, after a long journey of reinventing the wheel, I returned to the starting point and began considering **simpler and more practical solutions**.

## Format Keyword Implementation

The [Format keyword](#format-keyword) in JSON Schema provides validation functionality based on various **RFC standards**. For example, it can validate specific string formats like `date-time` or `uri`.

I determined that this functionality was too broad to be included in the same library. Therefore, I decided to separate it into a **separate library** and provide an interface similar to the familiar native [JSON API](#json-api) and [Date API](#date-api).

```ts
import { FullTime } from "@imhonglu/format";

// Parse time string according to RFC standard
const time = FullTime.parse("15:59:60.123-08:00", {
  year: 1998,
  month: 12,
  day: 31,
});
// Result:
// {
//   hour: 15,        // Hour
//   minute: 59,      // Minute
//   second: 60,      // Second (considering leap second)
//   secfrac: ".123", // Fraction of second
//   offset: {        // Timezone offset
//     sign: "-",     // Sign
//     hour: 8,       // Hour
//     minute: 0      // Minute
//   }
// }

// Convert to standard format string
console.log(FullTime.stringify(time));
// '15:59:60.123-08:00'

// Support JSON serialization
console.log(JSON.stringify(time));
// '"15:59:60.123-08:00"'

// Automatic serialization within objects
console.log(
  JSON.stringify({
    name: "John",
    createdAt: time,  // FullTime instance automatically converts to string
  })
)
// '{"name":"John","createdAt":"15:59:60.123-08:00"}'
```

### Serializable Decorator

First, I implemented the [Serializable Decorator](#serializable-decorator) to easily define frequently used [Formatter](#formatter)s.

```ts
import {
  type Fn,
  type SafeResult,
  createSafeExecutor,
} from "@imhonglu/toolkit";

export function Serializable<
  T extends Fn.Newable & {
    parse: Fn.Callable<{ return: InstanceType<T> }>;
    safeParse: Fn.Callable<{ return: SafeResult<InstanceType<T>> }>;
    stringify: Fn.Callable<{ args: [InstanceType<T>]; return: string }>;
  },
>(targetClass: T) { ... }
```

I used the `Decorator` for two reasons:

1. The ability to use `Generic` to make it behave like an `Abstract Implement Class` ([Related Issue](#abstract-implement-class-related-issue))
2. The ability to automatically implement or enforce implementation of specific methods (`parse`, `stringify`, `safeParse`, etc.)

For example, applying `@Serializable` enforces implementation:

```ts
@Serializable
// ^^^^^^^^^^
// Compilation error if `parse`, `stringify`, `safeParse` are not implemented
class MyClass { ... }
```

It also automatically implements `toString()`, `toJSON()`, and `safeParse()` methods:

```ts
@Serializable
class MyClass {
  ...
  // `toString()`, `toJSON()`, `safeParse()` are automatically implemented
}
```

This approach allows us to automate method implementation while clearly enforcing interfaces.

### ABNF Grammar and Regular Expressions

When converting [ABNF](#abnf-wiki) grammar from RFC documents to regular expressions, we faced issues with code **reusability and debugging**. This limitation was particularly evident in the `uri` implementation from [RFC 3986](#rfc-3986).

For example, with regular expressions like this, it was **very difficult to identify where problems occurred** if certain characters were missing or updated:

```ts
const userinfo = /[a-zA-Z0-9\-._~!$&'()*+,;=:]+/;
```

#### üöÄ Solution: Improvement through Pattern Assembly

To solve this problem, I developed the [@imhonglu/pattern-builder](#imhonglupattern-builder) library applying the [Builder Pattern](#builder-pattern). This allows us to **convert ABNF grammar into more intuitive and maintainable code**.

First, define the most basic patterns:

```ts
import { characterSet, concat, hexDigit } from "@imhonglu/pattern-builder";

export const unreserved = characterSet(alpha, digit, /[\-._~]/);
export const pctEncoded = concat("%", hexDigit.clone().exact(2));
export const subDelims = characterSet(/[!$&'()*+,;=]/);
```

These defined patterns can be combined to create more complex rules:

```ts
export const pchar = oneOf(
  pctEncoded,
  characterSet(unreserved, subDelims, /[:@]/),
);
```

Finally, complete the **URI path pattern**:

```ts
const slash = characterSet("/").optional();

const path = concat(
  concat(slash, pchar.clone().nonCapturingGroup().oneOrMore())
    .nonCapturingGroup()
    .zeroOrMore(),
  // Optional trailing slash
  slash,
)
  .anchor()
  .toRegExp();
```

#### ‚úÖ These improvements made things much better!

Thanks to the step-by-step pattern definition approach:

- We can more clearly express the **intent and role** of ABNF rules
- Each pattern can be modified and reused independently
- We can test and debug specific parts separately

These improvements significantly enhanced **code readability and maintainability**, ultimately becoming a solid foundation for the [@imhonglu/format](#imhongluformat) library.

## Type Inference

After establishing the foundation through Format keyword implementation and test automation, the most crucial aspect in a TypeScript environment was **type safety**. The final challenge was to effectively implement type inference for JSON Schema.

Rather than simply inferring based on the `type` keyword, we needed an **extensible type system that reflects the structural characteristics of the schema**.

### Structuring the Type System

First, we defined the `type` keyword as a **Discriminated Union** to narrow down possible types in advance.
This allowed us to utilize TypeScript's **Control Flow Analysis** for automatic type inference.

However, JSON Schema is not defined by simple `type` properties alone.
There are various keywords for validation, which needed to be managed systematically.

Therefore, we adopted an approach of **separating major keywords used in JSON Schema into reusable interfaces**,
clearly defining necessary properties for each type.

We organized these into six main categories based on the documentation:

1. **`BasicMetaData`** - Metadata properties like `title`, `description`, `default`
2. **`StructuralValidation`** - Properties for structural validation of numbers, strings, arrays, etc.
3. **`StringEncodedData`** - String data-related properties like `contentEncoding`, `contentMediaType`
4. **`Format`** - Format validation like `date-time`, `email`, `uri`
5. **`ApplyingSubSchema`** - Sub-schema related properties like `$ref`, `allOf`, `oneOf`, `anyOf`
6. **`UnevaluatedLocations`** - Additional property definitions like `unevaluatedProperties`, `unevaluatedItems`

Let's look at `StructuralValidation` as an example:

```ts
export namespace StructuralValidation {
  /**
   * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.2 | Numeric}
   */
  export interface Numeric {
    multipleOf?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    minimum?: number;
    exclusiveMinimum?: number;
  }

  /**
   * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-6.3 | String}
   */
  export interface String {
    maxLength?: number;
    minLength?: number;
    pattern?: string;
  }
  // ... omitted
```

By separating each property into independent interfaces, we can **compose desired schema types by combining only the necessary properties**.

### Defining JSON Schema Types

Based on the separated structure above, we can define the top-level JSON Schema type:

```ts
/**
 * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-01#section-4.3.1 | ObjectSchema}
 */
export interface ObjectSchema
  extends Core<JsonSchema>,
    BasicMetaData,
    StructuralValidation.All,
    StringEncodedData<JsonSchema>,
    Format,
    ApplyingSubSchema.All<JsonSchema>,
    UnevaluatedLocations.All<JsonSchema> {}

/**
 * @see {@link https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-01#section-4.3.2 | BooleanSchema}
 */
export type BooleanSchema = boolean;

export type JsonSchema = ObjectSchema | BooleanSchema;
```

Now we can **integrate the core type structure of JSON Schema** into one.

This can be extended to define more specific types:

```ts
export namespace SchemaDefinition {
  // ... omitted

  export interface NumericType
    extends Core<Type>,
      BasicMetaData,
      Pick<StructuralValidation.Any, "type">,
      StructuralValidation.Numeric {
    type: "number" | "integer";
  }

  export type Type =
    | BooleanSchema
    | ConstType
    | EnumType
    | NullType
    | BooleanType
    | ObjectType
    | ArrayType
    | StringType
    | NumericType
    | Schema;
}
```

### Applying Type Inference

By applying the types defined above as `Generic`s to the `Schema` class, we designed it to **statically infer** the structure of JSON Schema:

```ts
export class Schema<T extends SchemaDefinition.Type = SchemaDefinition.Type> {
  constructor(public schema: T) {}
  // ... omitted
}
```

```ts
// Schema instance creation example
const schema = new Schema({
  type: "object",
  // ‚úÖ TypeScript infers only valid keywords for 'object' type
  // e.g., properties, required, additionalProperties, etc.
  properties: {
    name: { 
      type: "string",
      // ‚úÖ TypeScript infers only valid keywords for 'string' type
      // e.g., maxLength, minLength, pattern, etc.
      maxLength: 10,
    },
  },
});
```

This allows us to actively utilize TypeScript's type checking when defining schemas to **reduce developer mistakes and perform safe data validation**.

## JSON Schema Implementation Introduction

Let's look at how the library we developed works in practice, after solving various challenges explained so far.

The demo below shows how type inference works:

![../../../../public/blog/post-1/demo.gif](../../../../public/blog/post-1/demo.gif)

### üõ† Library Features

- Complies with JSON Schema 2020-12 Draft specification
- Statically infers appropriate keywords when defining schemas
- Statically infers types from defined schemas
- Supports recursive type inference for nested `Schema Instance`s
- Enables type inference based on the `required` keyword
- Provides `parse` and `stringify` methods for easy schema conversion and utilization
- Verified based on [JSON-Schema-test-suite](#json-schema-test-suite)

Unexpectedly, I ended up spending more time on creating automated test cases based on JSON-Schema-test-suite than solving simple type problems during development. Additionally, considerable effort went into analyzing RFC specifications to support the `format` keyword. While this process took longer than anticipated, it ultimately helped improve the project's completeness.

### üöÄ Future Plans

While basic functionality is implemented, there's still room for improvement. Going forward, I plan to focus on developing the following areas:

1. **Custom Functionality**
   - Customizing schema validation messages
   - Custom error handling
   - Supporting validation rule extensions

2. **Developer Experience Improvements**
   - Providing more detailed error messages and debugging information
   - Improving documentation

3. **Performance Optimization**
   - Optimizing schema compilation process
   - Improving memory usage

### ü§ù Contributing

This project is still evolving and welcomes community feedback and contributions. If you're interested, please visit the [repository](https://github.com/imhonglu/new-wheels/tree/main/libs/json-schema).

Your opinions and suggestions will be the driving force in further improving this library. Thank you!

## References

#### [Zod](https://zod.dev/)
A powerful library that ensures type safety in TypeScript and can validate various data structures. Particularly useful for easy schema-based data validation.

#### [class-validator](https://github.com/typestack/class-validator)
Used with `NestJS`, this library enables object validation using decorators. Provides various validation decorators.

#### [Ajv](https://github.com/ajv-validator/ajv)
A high-performance library widely used in Node.js environments for data validation using JSON Schema. Supports the latest JSON Schema standards.

#### [JSON Type Definition](https://json-schema.org/draft/2020-12/json-schema-type-definitions)
A standard specification for defining and validating JSON data types, offering more concise syntax than JSON Schema.

#### [JSON Schema](https://json-schema.org/)
A draft specification for defining and validating JSON data structures, supporting various data formats and ensuring data validity.

#### [Ajv TypeScript](https://ajv.js.org/guide/typescript.html#utility-types-for-schemas)
Documentation on using Ajv's TypeScript utility types to enhance interoperability between JSON Schema and TypeScript types.

#### [TS Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)
A powerful API for programmatically analyzing and transforming TypeScript code, utilizing TypeScript compiler's internal functionality.

#### [Format Keyword](https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-01#section-7)
A keyword in JSON Schema for validating specific string formats, enabling validation of various data formats.

#### [JSON-Schema-Test-Suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite)
Official test case collection for verifying JSON Schema implementation accuracy.

#### [JSON-Schema-Test-Suite/tree/main/tests](https://github.com/json-schema-org/JSON-Schema-Test-Suite/tree/main/tests)
Directory containing test schemas for JSON Schema Test Suite, including various test cases.

#### [Bowtie](https://docs.bowtie.report/en/stable/)
A CLI tool for automating JSON Schema implementation tests, enabling easy execution of various test cases.

#### [JSON API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON)
Standard API for handling JSON data in JavaScript, enabling conversion between JSON strings and objects.

#### [Date API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date)
Standard API for handling dates and times in JavaScript, allowing creation and manipulation of date objects.

#### Formatter
Internal implementation term referring to string format validation based on RFC standards.

#### [Serializable Decorator](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/utils/serializable/serializable.ts)
A `Class Decorator` for implementing [Formatter](#formatter).

#### [Abstract Implement Class Related Issue](https://github.com/microsoft/TypeScript/issues/22815)
TypeScript issue discussing abstract implementation class details.

#### [ABNF WIKI](https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form)
Wiki about ABNF used in RFC documents, explaining formal language grammar definition methods.

#### [RFC 5234](https://datatracker.ietf.org/doc/html/rfc5234)
RFC document defining ABNF, providing standards for formal language grammar definition.

#### [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986)
RFC document defining URI general syntax, explaining URI structure and format.

#### [@imhonglu/pattern-builder](https://github.com/imhonglu/new-wheels/blob/main/libs/pattern-builder/src/index.ts)
Library helping write regular expressions easily, enabling simple construction of complex patterns.

#### [@imhonglu/format](https://github.com/imhonglu/new-wheels/blob/main/libs/format/src/index.ts)
Library for string format validation based on RFC documents, enabling validation of various string formats.

#### [Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern)
An object creation pattern that simplifies complex object creation processes and provides flexibility.
